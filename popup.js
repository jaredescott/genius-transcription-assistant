// Popup script for Genius Transcription Assistant
document.addEventListener('DOMContentLoaded', () => {
  // Tab switching
  const tabBtns = document.querySelectorAll('.tab-btn');
  const tabPanes = document.querySelectorAll('.tab-pane');
  
  tabBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const tabId = btn.dataset.tab;
      
      // Update button states
      tabBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Update pane visibility
      tabPanes.forEach(pane => {
        pane.classList.remove('active');
        if (pane.id === `tab-${tabId}`) {
          pane.classList.add('active');
        }
      });
    });
  });

  // Transcription functionality
  const urlInput = document.getElementById('youtube-url');
  const btnGetCurrent = document.getElementById('btn-get-current');
  const btnFetch = document.getElementById('btn-fetch-transcript');
  const langSelect = document.getElementById('transcript-lang');
  const statusEl = document.getElementById('transcribe-status');
  const btnToggleSettings = document.getElementById('btn-toggle-settings');
  const apiSettings = document.getElementById('api-settings');
  const apiKeyInput = document.getElementById('api-key-input');
  const btnSaveApiKey = document.getElementById('btn-save-api-key');
  const useLocalServerCheckbox = document.getElementById('use-local-server');
  const preferYouTubeCaptionsCheckbox = document.getElementById('prefer-youtube-captions');
  const serverPortInput = document.getElementById('server-port');
  const btnTestServer = document.getElementById('btn-test-server');
  const videoInfoEl = document.getElementById('video-info');
  const transcriptOutput = document.getElementById('transcript-output');
  const transcriptText = document.getElementById('transcript-text');
  const btnCopy = document.getElementById('btn-copy');
  const btnFormat = document.getElementById('btn-format');
  const btnClear = document.getElementById('btn-clear');
  const availableLangsEl = document.getElementById('available-langs');
  const langButtonsEl = document.getElementById('lang-buttons');

  let currentVideoId = null;
  let currentTranscript = null;
  let transcriptionInProgress = false;

  // State persistence functions
  async function saveTranscriptionState(state) {
    try {
      await chrome.storage.local.set({ transcriptionState: state });
    } catch (error) {
      console.error('Failed to save transcription state:', error);
    }
  }

  async function loadTranscriptionState() {
    try {
      const result = await chrome.storage.local.get(['transcriptionState']);
      return result.transcriptionState || null;
    } catch (error) {
      console.error('Failed to load transcription state:', error);
      return null;
    }
  }

  async function clearTranscriptionState() {
    try {
      await chrome.storage.local.remove(['transcriptionState']);
    } catch (error) {
      console.error('Failed to clear transcription state:', error);
    }
  }

  // Restore state on popup open
  async function restoreTranscriptionState() {
    const savedState = await loadTranscriptionState();
    if (!savedState) return;

    // Restore video info
    if (savedState.videoId) {
      currentVideoId = savedState.videoId;
      urlInput.value = savedState.url || `https://www.youtube.com/watch?v=${savedState.videoId}`;
      
      if (savedState.videoInfo) {
        showVideoInfo(savedState.videoInfo);
      } else {
        await fetchVideoInfo(savedState.videoId);
      }
    }

    // Restore transcript if completed
    if (savedState.transcript && savedState.status === 'completed') {
      currentTranscript = savedState.transcript;
      transcriptText.value = savedState.transcript.text || '';
      
      // Restore language info
      const langInfo = document.getElementById('transcript-lang-info');
      const autoBadge = document.getElementById('transcript-auto-badge');
      
      if (langInfo && savedState.transcript.language) {
        langInfo.textContent = savedState.transcript.language.toUpperCase();
      }
      
      if (autoBadge && savedState.transcript.source) {
        if (savedState.transcript.source === 'local-server' || savedState.transcript.source === 'whisper' || savedState.transcript.source === 'transcribe-anything') {
          autoBadge.textContent = 'Python Server';
          autoBadge.classList.remove('hidden');
        } else if (savedState.transcript.source === 'assemblyai') {
          autoBadge.textContent = 'AI Transcription';
          autoBadge.classList.remove('hidden');
        } else if (savedState.transcript.isAutoGenerated) {
          autoBadge.textContent = 'Auto-generated';
          autoBadge.classList.remove('hidden');
        }
      }

      // Show available languages
      if (savedState.transcript.availableLanguages && savedState.transcript.availableLanguages.length > 1) {
        showAvailableLanguages(savedState.transcript.availableLanguages, savedState.videoId);
      }

      transcriptOutput.classList.remove('hidden');
      showStatus('Transcript restored from previous session', 'success');
    } else if (savedState.status === 'in_progress') {
      // Show that transcription was in progress
      showStatus('Transcription was in progress. Click "Get Transcript" to retry.', 'info');
      btnFetch.disabled = false;
    }
  }

  // Initialize: restore state on popup open
  restoreTranscriptionState();

  // Get video from current tab
  btnGetCurrent.addEventListener('click', async () => {
    try {
      showStatus('Getting video from current tab...', 'info');
      
      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
      
      if (!tab || !tab.url) {
        showStatus('Could not access current tab', 'error');
        return;
      }
      
      // Check if it's a YouTube page
      if (tab.url.includes('youtube.com') || tab.url.includes('youtu.be')) {
        // Try to get info from content script first
        try {
          const response = await chrome.tabs.sendMessage(tab.id, { action: 'getYouTubeVideoInfo' });
          if (response && response.success) {
            urlInput.value = tab.url;
            currentVideoId = response.videoId;
            currentVideoInfo = response;
            showVideoInfo(response);
            showStatus('Video found! Click "Get Transcript" to fetch.', 'success');
            return;
          }
        } catch (e) {
          // Content script not available, extract from URL
        }
        
        // Extract from URL
        const videoId = extractVideoId(tab.url);
        if (videoId) {
          urlInput.value = tab.url;
          currentVideoId = videoId;
          await fetchVideoInfo(videoId);
          showStatus('Video found! Click "Get Transcript" to fetch.', 'success');
        } else {
          showStatus('Could not extract video ID from URL', 'error');
        }
      } else if (tab.url.includes('genius.com')) {
        // Try to find YouTube embed on Genius page
        showStatus('Looking for YouTube video on Genius page...', 'info');
        try {
          // Wait a bit for content script to be ready
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // First, try using the content script if available
          let foundVideo = false;
          try {
            const response = await chrome.tabs.sendMessage(tab.id, { action: 'getYouTubeVideoFromGenius' });
            if (response && response.success && response.videoUrl) {
              urlInput.value = response.videoUrl;
              const videoId = extractVideoId(response.videoUrl);
              if (videoId) {
                currentVideoId = videoId;
                currentVideoInfo = response.videoInfo || null;
                if (currentVideoInfo) {
                  showVideoInfo(currentVideoInfo);
                } else {
                  await fetchVideoInfo(videoId);
                }
                showStatus('YouTube video found on Genius page!', 'success');
                foundVideo = true;
              }
            }
          } catch (e) {
            // Content script might not be ready, fall back to injected script
            console.log('Content script not available, using injected script:', e.message);
          }
          
          if (foundVideo) return;
          
          // Fallback: inject script to find YouTube video
          const results = await chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: findYouTubeOnGeniusPage
          });
          
          if (results && results[0] && results[0].result) {
            urlInput.value = results[0].result;
            const videoId = extractVideoId(results[0].result);
            if (videoId) {
              currentVideoId = videoId;
              await fetchVideoInfo(videoId);
              showStatus('YouTube video found on Genius page!', 'success');
            } else {
              showStatus('Found YouTube URL but could not extract video ID', 'error');
            }
          } else {
            showStatus('No YouTube video found on this Genius page. Make sure the page has a YouTube embed.', 'error');
          }
        } catch (e) {
          console.error('Error searching Genius page:', e);
          showStatus(`Could not search Genius page: ${e.message}`, 'error');
        }
      } else {
        showStatus('Please navigate to a YouTube video or Genius song page', 'error');
      }
    } catch (error) {
      showStatus(`Error: ${error.message}`, 'error');
    }
  });

  // Fetch transcript
  btnFetch.addEventListener('click', async () => {
    const url = urlInput.value.trim();
    
    if (!url) {
      showStatus('Please enter a YouTube URL or video ID', 'error');
      return;
    }
    
    const videoId = extractVideoId(url);
    if (!videoId) {
      showStatus('Invalid YouTube URL or video ID', 'error');
      return;
    }
    
    currentVideoId = videoId;
    await fetchTranscript(videoId, langSelect.value);
  });

  // URL input change - auto-detect video
  urlInput.addEventListener('input', debounce(async () => {
    const url = urlInput.value.trim();
    if (url.length > 5) {
      const videoId = extractVideoId(url);
      if (videoId && videoId !== currentVideoId) {
        currentVideoId = videoId;
        await fetchVideoInfo(videoId);
      }
    }
  }, 500));

  // Copy transcript
  btnCopy.addEventListener('click', async () => {
    const text = transcriptText.value;
    if (!text) {
      showStatus('No transcript to copy', 'error');
      return;
    }
    
    try {
      await navigator.clipboard.writeText(text);
      showStatus('Copied to clipboard!', 'success');
    } catch (e) {
      // Fallback for older browsers
      transcriptText.select();
      document.execCommand('copy');
      showStatus('Copied to clipboard!', 'success');
    }
  });

  // Format for Genius
  btnFormat.addEventListener('click', () => {
    let text = transcriptText.value;
    if (!text) {
      showStatus('No transcript to format', 'error');
      return;
    }
    
    text = formatForGenius(text);
    transcriptText.value = text;
    showStatus('Formatted for Genius!', 'success');
  });

  // Clear transcript
  btnClear.addEventListener('click', async () => {
    transcriptText.value = '';
    transcriptOutput.classList.add('hidden');
    availableLangsEl.classList.add('hidden');
    videoInfoEl.classList.add('hidden');
    currentTranscript = null;
    urlInput.value = '';
    currentVideoId = null;
    await clearTranscriptionState();
    hideStatus();
  });

  // Helper functions
  function extractVideoId(url) {
    if (!url) return null;
    
    const patterns = [
      /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
      /^([a-zA-Z0-9_-]{11})$/ // Direct video ID
    ];
    
    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) return match[1];
    }
    
    return null;
  }

  let currentVideoInfo = null;
  
  async function fetchVideoInfo(videoId) {
    try {
      const response = await chrome.runtime.sendMessage({
        action: 'getVideoInfo',
        videoId
      });
      
      if (response && response.success) {
        currentVideoInfo = response.info;
        showVideoInfo(response.info);
      }
    } catch (e) {
      console.error('Error fetching video info:', e);
    }
  }

  function showVideoInfo(info) {
    const thumbEl = document.getElementById('video-thumb');
    const titleEl = document.getElementById('video-title');
    const channelEl = document.getElementById('video-channel');
    
    thumbEl.src = `https://img.youtube.com/vi/${info.videoId}/mqdefault.jpg`;
    titleEl.textContent = info.title || 'Unknown Title';
    channelEl.textContent = info.channel || 'Unknown Channel';
    
    videoInfoEl.classList.remove('hidden');
  }

  async function fetchTranscript(videoId, lang) {
    try {
      transcriptionInProgress = true;
      
      // Get user preference for YouTube captions (default: false = use Python server first)
      const preferYouTubeCaptions = preferYouTubeCaptionsCheckbox ? preferYouTubeCaptionsCheckbox.checked : false;
      
      // Show appropriate status based on preference
      if (preferYouTubeCaptions) {
        showStatus('Checking YouTube captions...', 'info');
      } else {
        showStatus('Transcribing with Python server...', 'info');
      }
      
      btnFetch.disabled = true;
      
      // Save state: transcription started
      await saveTranscriptionState({
        videoId,
        url: urlInput.value.trim(),
        status: 'in_progress',
        videoInfo: currentVideoInfo && currentVideoId === videoId ? currentVideoInfo : null,
        timestamp: Date.now()
      });
      
      console.log('Popup: Sending transcript request for video:', videoId);
      
      // Add timeout handling (longer timeout for transcription)
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error('Request timeout after 5 minutes. Check server terminal for transcription progress.'));
        }, 300000); // 5 minutes for transcription
      });
      
      const messagePromise = chrome.runtime.sendMessage({
        action: 'fetchTranscript',
        videoId,
        lang: lang === 'auto' ? 'en' : lang,
        preferYouTubeCaptions: preferYouTubeCaptions
      });
      
      console.log('Popup: Waiting for response...');
      
      // Update status periodically while waiting
      let statusUpdateCount = 0;
      const statusInterval = setInterval(() => {
        statusUpdateCount++;
        if (preferYouTubeCaptions) {
          // User prefers YouTube captions first
          if (statusUpdateCount === 3) {
            showStatus('No captions found, trying Python server...', 'info');
          } else if (statusUpdateCount > 5) {
            showStatus('Transcribing (this may take a few minutes)...', 'info');
          }
        } else {
          // Default: Python server first
          if (statusUpdateCount === 3) {
            showStatus('Python server taking longer than expected...', 'info');
          } else if (statusUpdateCount > 5) {
            showStatus('Still transcribing (this may take a few minutes)...', 'info');
          }
        }
      }, 5000); // Update every 5 seconds
      
      const response = await Promise.race([messagePromise, timeoutPromise]);
      clearInterval(statusInterval);
      console.log('Popup: Received response:', response);
      
      if (response && response.success) {
        currentTranscript = response.transcript;
        transcriptText.value = response.transcript.text;
        
        // Update language info
        const langInfo = document.getElementById('transcript-lang-info');
        const autoBadge = document.getElementById('transcript-auto-badge');
        
        langInfo.textContent = response.transcript.language.toUpperCase();
        
        // Show source badge if using fallback
        if (response.transcript.source === 'local-server' || response.transcript.source === 'whisper' || response.transcript.source === 'transcribe-anything') {
          autoBadge.textContent = 'Python Server';
          autoBadge.classList.remove('hidden');
        } else if (response.transcript.source === 'assemblyai') {
          autoBadge.textContent = 'AI Transcription';
          autoBadge.classList.remove('hidden');
        } else if (response.transcript.isAutoGenerated) {
          autoBadge.textContent = 'Auto-generated';
          autoBadge.classList.remove('hidden');
        } else {
          autoBadge.classList.add('hidden');
        }
        
        // Show available languages
        if (response.transcript.availableLanguages && response.transcript.availableLanguages.length > 1) {
          showAvailableLanguages(response.transcript.availableLanguages, videoId);
        }
        
        transcriptOutput.classList.remove('hidden');
        let sourceMsg = '';
        if (response.transcript.source === 'local-server' || response.transcript.source === 'whisper' || response.transcript.source === 'transcribe-anything') {
          sourceMsg = ' (using Python server)';
        } else if (response.transcript.source === 'assemblyai') {
          sourceMsg = ' (using AI transcription)';
        }
        showStatus(`Transcript fetched successfully!${sourceMsg}`, 'success');
        
        // Save state: transcription completed
        await saveTranscriptionState({
          videoId,
          url: urlInput.value.trim(),
          status: 'completed',
          transcript: response.transcript,
          videoInfo: currentVideoInfo && currentVideoId === videoId ? currentVideoInfo : null,
          timestamp: Date.now()
        });
      } else {
        const errorMsg = response?.error || 'Failed to fetch transcript';
        console.error('Transcript fetch failed:', errorMsg);
        showStatus(errorMsg, 'error');
        
        // Save state: transcription failed
        await saveTranscriptionState({
          videoId,
          url: urlInput.value.trim(),
          status: 'error',
          error: errorMsg,
          videoInfo: currentVideoInfo && currentVideoId === videoId ? currentVideoInfo : null,
          timestamp: Date.now()
        });
        
        // If it's a local server error, provide helpful message
        if (errorMsg.includes('local server') || errorMsg.includes('Cannot connect')) {
          showStatus(`${errorMsg}. Make sure transcription_server.py is running.`, 'error');
        }
      }
    } catch (error) {
      console.error('Transcript fetch error:', error);
      const errorMsg = error.message || 'Unknown error occurred';
      showStatus(`Error: ${errorMsg}`, 'error');
      
      // Save state: transcription error
      await saveTranscriptionState({
        videoId,
        url: urlInput.value.trim(),
        status: 'error',
        error: errorMsg,
        videoInfo: currentVideoInfo && currentVideoId === videoId ? currentVideoInfo : null,
        timestamp: Date.now()
      });
      
      // Check if it's a timeout
      if (errorMsg.includes('timeout')) {
        showStatus('Request timed out. The video may not have captions. Make sure the Python server is running for fallback transcription.', 'error');
      }
    } finally {
      transcriptionInProgress = false;
      btnFetch.disabled = false;
    }
  }

  function showAvailableLanguages(languages, videoId) {
    langButtonsEl.innerHTML = '';
    
    languages.forEach(lang => {
      const btn = document.createElement('button');
      btn.className = 'lang-btn';
      btn.textContent = `${lang.name}${lang.isAuto ? ' (auto)' : ''}`;
      btn.dataset.langCode = lang.code;
      
      btn.addEventListener('click', () => {
        fetchTranscript(videoId, lang.code);
      });
      
      langButtonsEl.appendChild(btn);
    });
    
    availableLangsEl.classList.remove('hidden');
  }

  function formatForGenius(text) {
    // Apply Genius.com formatting guidelines
    let lines = text.split('\n');
    let formatted = [];
    
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();
      
      // Skip empty lines but preserve stanza breaks
      if (!line) {
        // Add a blank line for stanza separation (if not already added)
        if (formatted.length > 0 && formatted[formatted.length - 1] !== '') {
          formatted.push('');
        }
        continue;
      }
      
      // Capitalize first letter of each line
      line = line.charAt(0).toUpperCase() + line.slice(1);
      
      // Fix straight apostrophes to curly
      line = line.replace(/(\w)'(\w)/g, '$1\u2019$2');
      line = line.replace(/(\w)'(\s|$|,|\.|!|\?)/g, '$1\u2019$2');
      
      // Fix straight quotes to curly
      let quoteCount = 0;
      line = line.replace(/"/g, () => {
        quoteCount++;
        return quoteCount % 2 === 1 ? '\u201C' : '\u201D';
      });
      
      formatted.push(line);
    }
    
    // Remove trailing empty lines
    while (formatted.length > 0 && formatted[formatted.length - 1] === '') {
      formatted.pop();
    }
    
    return formatted.join('\n');
  }

  function showStatus(message, type) {
    statusEl.textContent = message;
    statusEl.className = `status ${type}`;
    statusEl.classList.remove('hidden');
  }

  function hideStatus() {
    statusEl.classList.add('hidden');
  }

  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // API Key Settings
  if (btnToggleSettings) {
    btnToggleSettings.addEventListener('click', () => {
      apiSettings.classList.toggle('hidden');
    });
  }

  // Load saved settings
  chrome.storage.local.get(['transcriptionApiKey', 'useLocalServer', 'localServerPort', 'preferYouTubeCaptions'], (result) => {
    if (result.transcriptionApiKey && apiKeyInput) {
      apiKeyInput.value = result.transcriptionApiKey;
    }
    if (useLocalServerCheckbox) {
      useLocalServerCheckbox.checked = result.useLocalServer !== false; // Default to true
    }
    if (preferYouTubeCaptionsCheckbox) {
      preferYouTubeCaptionsCheckbox.checked = result.preferYouTubeCaptions === true; // Default to false
    }
    if (serverPortInput) {
      serverPortInput.value = result.localServerPort || 8765;
    }
  });

  // Save local server settings
  if (useLocalServerCheckbox) {
    useLocalServerCheckbox.addEventListener('change', () => {
      chrome.storage.local.set({ useLocalServer: useLocalServerCheckbox.checked });
    });
  }
  if (preferYouTubeCaptionsCheckbox) {
    preferYouTubeCaptionsCheckbox.addEventListener('change', () => {
      chrome.storage.local.set({ preferYouTubeCaptions: preferYouTubeCaptionsCheckbox.checked });
    });
  }

  if (serverPortInput) {
    serverPortInput.addEventListener('change', () => {
      const port = parseInt(serverPortInput.value) || 8765;
      chrome.storage.local.set({ localServerPort: port });
    });
  }

  // Test server connection
  if (btnTestServer) {
    btnTestServer.addEventListener('click', async () => {
      const port = parseInt(serverPortInput?.value) || 8765;
      showStatus('Testing connection...', 'info');
      
      try {
        const response = await fetch(`http://localhost:${port}/health`);
        const health = await response.json();
        
        if (health.status === 'ok') {
          showStatus(`✓ Server connected! Using ${health.dependencies}`, 'success');
        } else {
          showStatus(`✗ ${health.message}`, 'error');
        }
      } catch (error) {
        showStatus(`✗ Cannot connect to server on port ${port}`, 'error');
      }
    });
  }

  // Save API key
  if (btnSaveApiKey) {
    btnSaveApiKey.addEventListener('click', async () => {
      const apiKey = apiKeyInput.value.trim();
      if (!apiKey) {
        showStatus('Please enter an API key', 'error');
        return;
      }

      try {
        const response = await chrome.runtime.sendMessage({
          action: 'setApiKey',
          apiKey
        });

        if (response && response.success) {
          showStatus('API key saved!', 'success');
        }
      } catch (error) {
        showStatus('Failed to save API key', 'error');
      }
    });
  }
});

// Function to find YouTube video on Genius page (executed in content script context)
function findYouTubeOnGeniusPage() {
  // Method 1: Look for YouTube iframes (including lazy-loaded ones)
  const iframes = document.querySelectorAll('iframe');
  
  for (const iframe of iframes) {
    // Check src attribute
    let src = iframe.src || iframe.getAttribute('src') || '';
    
    // Check data-src for lazy loading
    if (!src) {
      src = iframe.getAttribute('data-src') || '';
    }
    
    // Check data-youtube-id attribute (some sites use this)
    const youtubeId = iframe.getAttribute('data-youtube-id');
    if (youtubeId && youtubeId.match(/^[a-zA-Z0-9_-]{11}$/)) {
      return `https://www.youtube.com/watch?v=${youtubeId}`;
    }
    
    if (src) {
      // Check for various YouTube embed patterns
      const patterns = [
        /(?:youtube\.com\/embed\/|youtube-nocookie\.com\/embed\/|youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
        /[?&]v=([a-zA-Z0-9_-]{11})/,
        /youtu\.be\/([a-zA-Z0-9_-]{11})/
      ];
      
      for (const pattern of patterns) {
        const match = src.match(pattern);
        if (match && match[1]) {
          return `https://www.youtube.com/watch?v=${match[1]}`;
        }
      }
    }
  }
  
  // Method 2: Look for YouTube links in the page
  const links = document.querySelectorAll('a[href*="youtube.com"], a[href*="youtu.be"]');
  for (const link of links) {
    const href = link.href || link.getAttribute('href') || '';
    if (href.match(/youtube\.com\/watch|youtu\.be/)) {
      // Extract video ID to ensure it's valid
      const videoIdMatch = href.match(/(?:v=|youtu\.be\/|embed\/)([a-zA-Z0-9_-]{11})/);
      if (videoIdMatch) {
        return `https://www.youtube.com/watch?v=${videoIdMatch[1]}`;
      }
    }
  }
  
  // Method 3: Look for YouTube video IDs in data attributes or text content
  const videoIdPattern = /[a-zA-Z0-9_-]{11}/;
  const allElements = document.querySelectorAll('[data-video-id], [data-youtube-id], [data-youtube-video-id]');
  for (const el of allElements) {
    const videoId = el.getAttribute('data-video-id') || 
                   el.getAttribute('data-youtube-id') || 
                   el.getAttribute('data-youtube-video-id');
    if (videoId && videoId.match(videoIdPattern)) {
      return `https://www.youtube.com/watch?v=${videoId}`;
    }
  }
  
  // Method 4: Search in script tags for YouTube URLs (some sites embed via JS)
  const scripts = document.querySelectorAll('script');
  for (const script of scripts) {
    const content = script.textContent || script.innerHTML || '';
    const matches = content.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
    if (matches && matches[1]) {
      return `https://www.youtube.com/watch?v=${matches[1]}`;
    }
  }
  
  return null;
}
